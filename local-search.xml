<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>leetcode-784字母大小写全排列</title>
    <link href="/2022/10/30/leetcode-784%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <url>/2022/10/30/leetcode-784%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%B0%8F%E5%86%99%E5%85%A8%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个字符串 s ，通过将字符串 s 中的每个字母转变大小写，我们可以获得一个新的字符串。<br>返回 所有可能得到的字符串集合 。以 任意顺序 返回输出。</p><h1 id="广度优先"><a href="#广度优先" class="headerlink" title="广度优先"></a>广度优先</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCasePermutation</span><span class="hljs-params">(String s)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        Deque&lt;StringBuilder&gt; arrayQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>();<br>        arrayQueue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>());<br>        <span class="hljs-keyword">while</span>(arrayQueue.isEmpty() == <span class="hljs-literal">false</span>)&#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">curr</span> <span class="hljs-operator">=</span> arrayQueue.poll();<br>            <span class="hljs-keyword">if</span>(curr.length() == s.length() )&#123;<br>                list.add(curr.toString());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> curr.length();<br>                <span class="hljs-keyword">if</span>(Character.isLetter(s.charAt(pos)))&#123;<br>                    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">nextLow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(curr);<br>                    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">nextUp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(curr);<br>                    <span class="hljs-keyword">if</span>(s.charAt(pos) &gt;= <span class="hljs-string">&#x27;a&#x27;</span>)&#123;<br>                        nextUp.append( (<span class="hljs-type">char</span>)(s.charAt(pos) - <span class="hljs-number">32</span>) );<br>                        nextLow.append(s.charAt(pos));<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        nextUp.append( (<span class="hljs-type">char</span>)(s.charAt(pos) + <span class="hljs-number">32</span>) );<br>                        nextLow.append(s.charAt(pos));<br>                    &#125;<br>                    arrayQueue.add(nextLow);<br>                    arrayQueue.add(nextUp);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    arrayQueue.add(curr.append(s.charAt(pos))); <br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;     <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="深度优先"><a href="#深度优先" class="headerlink" title="深度优先"></a>深度优先</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">letterCasePermutation</span><span class="hljs-params">(String s)</span> &#123;<br>        digui(s.toCharArray(), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">digui</span><span class="hljs-params">(<span class="hljs-type">char</span>[] cs, <span class="hljs-type">int</span> index)</span>&#123;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(cs));<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; cs.length; i++)&#123;<br>                <span class="hljs-comment">// 为数字类型数据</span><br>                <span class="hljs-keyword">if</span>(cs[i] &lt; <span class="hljs-string">&#x27;A&#x27;</span>)&#123;<br>                    cs[i] = cs[i];<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cs[i] &gt;= <span class="hljs-string">&#x27;a&#x27;</span>)&#123;<br>                    cs[i] =  (<span class="hljs-type">char</span>)(cs[i] - <span class="hljs-number">32</span>);<br>                    digui(cs, i+<span class="hljs-number">1</span>);<br>                    cs[i] =  (<span class="hljs-type">char</span>)(cs[i] + <span class="hljs-number">32</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    cs[i] =  (<span class="hljs-type">char</span>)(cs[i] + <span class="hljs-number">32</span>);<br>                    digui(cs, i+<span class="hljs-number">1</span>);<br>                    cs[i] =  (<span class="hljs-type">char</span>)(cs[i] - <span class="hljs-number">32</span>);  <br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>深度优先 广度优先</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-907子数组的最小值之和</title>
    <link href="/2022/10/29/leetcode-907%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C/"/>
    <url>/2022/10/29/leetcode-907%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="题目：给定一个整数数组-arr，找到-min-b-的总和，其中-b-的范围为-arr-的每个（连续）子数组。"><a href="#题目：给定一个整数数组-arr，找到-min-b-的总和，其中-b-的范围为-arr-的每个（连续）子数组。" class="headerlink" title="题目：给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。"></a>题目：给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。</h1><p>由于答案可能很大，因此 返回答案模 10^9 + 7 </p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/sum-of-subarray-minimums">https://leetcode.cn/problems/sum-of-subarray-minimums</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="回溯枚举所有可能性时间复杂度超出范围"><a href="#回溯枚举所有可能性时间复杂度超出范围" class="headerlink" title="回溯枚举所有可能性时间复杂度超出范围"></a>回溯枚举所有可能性时间复杂度超出范围</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; list =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumSubarrayMins</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        digui(arr, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(List&lt;Integer&gt; itemList : list)&#123;<br>            <span class="hljs-type">int</span>[] arrTemp = itemList.stream().mapToInt(Integer::valueOf).toArray();<br>            Arrays.sort(arrTemp);<br>            res = (res + arrTemp[<span class="hljs-number">0</span>]) % <span class="hljs-number">1000000007</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">digui</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> index, List&lt;Integer&gt; ans, <span class="hljs-type">int</span> flag)</span>&#123;<br>        <span class="hljs-keyword">if</span>(index ==  arr.length)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> index; i &lt; arr.length; i++)&#123;<br>                ans.add(arr[i]);<br>                list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(ans));<br>                digui(arr, i+<span class="hljs-number">1</span>, ans, flag+<span class="hljs-number">1</span>);<br>                ans.remove(ans.size() - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(flag != <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">return</span> ;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sumSubarrayMins</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, tail = head, mod = (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= arr.length; i++)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> i == arr.length ? <span class="hljs-number">0</span> : arr[i];<br>            <span class="hljs-keyword">while</span>(head != tail &amp;&amp; arr[stack[tail - <span class="hljs-number">1</span>]] &gt; num)&#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span>  stack[--tail];<br>                <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span>  head != tail ? stack[tail-<span class="hljs-number">1</span>] : -<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> i;<br>                result =  (result + (<span class="hljs-type">long</span>)(n-h)*(t-n)*arr[n]) % mod;<br>            &#125;<br>            stack[tail++] =  i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>单调栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-1822数组元素积的符号</title>
    <link href="/2022/10/27/leetcode-1822%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%A7%AF%E7%9A%84%E7%AC%A6%E5%8F%B7/"/>
    <url>/2022/10/27/leetcode-1822%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%A7%AF%E7%9A%84%E7%AC%A6%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>已知函数 signFunc(x) 将会根据 x 的正负返回特定值：</p><p>如果 x 是正数，返回 1 。<br>如果 x 是负数，返回 -1 。<br>如果 x 是等于 0 ，返回 0 。<br>给你一个整数数组 nums 。令 product 为数组 nums 中所有元素值的乘积。</p><p>返回 signFunc(product) 。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/sign-of-the-product-of-an-array">https://leetcode.cn/problems/sign-of-the-product-of-an-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">arraySign</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[i] &lt; <span class="hljs-number">0</span>)&#123;  <span class="hljs-comment">// 统计负数出现的次数</span><br>                num++;  <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? ans : -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-862和至少为k的最短子数组</title>
    <link href="/2022/10/26/leetcode-862%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BAk%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2022/10/26/leetcode-862%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BAk%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个整数数组 nums 和一个整数 k ，找出 nums 中和至少为 k 的 最短非空子数组 ，并返回该子数组的长度。如果不存在这样的 子数组 ，返回 -1 。</p><p>子数组 是数组中 连续 的一部分。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k">https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="前缀和的朴素解法-时间复杂度为o-n2-超出正常范围"><a href="#前缀和的朴素解法-时间复杂度为o-n2-超出正常范围" class="headerlink" title="前缀和的朴素解法 时间复杂度为o(n2) 超出正常范围"></a>前缀和的朴素解法 时间复杂度为o(n2) 超出正常范围</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp =  <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &gt;= k)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + nums[i];<br>            <span class="hljs-keyword">if</span>(nums[i] == k)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(dp[i] &gt;= k)&#123;<br>                ans = Math.min(ans, i + <span class="hljs-number">1</span>);      <br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i - <span class="hljs-number">1</span>; j &gt;=<span class="hljs-number">0</span>; j--)&#123;<br>                <span class="hljs-keyword">if</span>(dp[i] - dp[j] &gt;= k)&#123;<br>                    ans = Math.min(ans, i - j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">return</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span>= Integer.MAX_VALUE ? -<span class="hljs-number">1</span> : ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="前缀和加-单调队列"><a href="#前缀和加-单调队列" class="headerlink" title="前缀和加 + 单调队列"></a>前缀和加 + 单调队列</h1><p><img src="/2022/10/26/leetcode-862%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BAk%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/image.jpg"></p><pre><code class="java">class Solution &#123;    public int shortestSubarray(int[] nums, int k) &#123;        long[] dp = new long[nums.length+1];        for(int i = 0; i &lt; nums.length; i++)&#123;            dp[i+1] = dp[i] + nums[i];        &#125;        int res = nums.length + 1;        Deque&lt;Integer&gt; queue = new ArrayDeque&lt;Integer&gt;();        for(int i = 0; i &lt;= nums.length; i++)&#123;            long presum = dp[i];            while(queue.isEmpty() == false &amp;&amp; presum - dp[queue.peekFirst()] &gt;= k)&#123;                res = Math.min(i - queue.pollFirst(), res);            &#125;            while(queue.isEmpty() == false &amp;&amp; presum &lt;= dp[queue.peekLast()])&#123;                queue.pollLast();            &#125;            queue.offerLast(i);        &#125;        return res &lt; nums.length + 1 ? res : -1;    &#125;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>前缀和 + 单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-934最短的桥</title>
    <link href="/2022/10/25/leetcode-934%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5/"/>
    <url>/2022/10/25/leetcode-934%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个大小为 n x n 的二元矩阵 grid ，其中 1 表示陆地，0 表示水域。</p><p>岛 是由四面相连的 1 形成的一个最大组，即不会与非组内的任何其他 1 相连。grid 中 恰好存在两座岛 。</p><p>你可以将任意数量的 0 变为 1 ，以使两座岛连接起来，变成 一座岛 。</p><p>返回必须翻转的 0 的最小数目。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/shortest-bridge">https://leetcode.cn/problems/shortest-bridge</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><p>利用广度优先每次向外走一层并将值置为-1, 最后向外漫延的最小层数就是走过的最小距离<br><img src="/2022/10/25/leetcode-934%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5/image.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">shortestBridge</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> grid.length;<br>        <span class="hljs-type">int</span>[][] dirs = &#123;&#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>&#125;&#125;;<br>        List&lt;<span class="hljs-type">int</span>[]&gt; island = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>        Queue&lt;<span class="hljs-type">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>)&#123;<br>                    queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;i,j&#125;);<br>                    grid[i][j] = -<span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">while</span>(queue.isEmpty() == <span class="hljs-literal">false</span>)&#123;<br>                        <span class="hljs-type">int</span>[] cell = queue.poll();<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> cell[<span class="hljs-number">0</span>], col = cell[<span class="hljs-number">1</span>];<br>                        island.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;row, col&#125;);<br>                        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++)&#123;<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">nextRow</span> <span class="hljs-operator">=</span> row + dirs[k][<span class="hljs-number">0</span>];<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">nextCol</span> <span class="hljs-operator">=</span> col + dirs[k][<span class="hljs-number">1</span>];<br>                            <span class="hljs-keyword">if</span>(nextRow &gt;= <span class="hljs-number">0</span> &amp;&amp; nextRow &lt; n &amp;&amp; nextCol &gt;= <span class="hljs-number">0</span> &amp;&amp; nextCol &lt; n &amp;&amp; grid[nextRow][nextCol] == <span class="hljs-number">1</span>)&#123;<br>                                queue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nextRow, nextCol&#125;);<br>                                grid[nextRow][nextCol] = -<span class="hljs-number">1</span>;<br>                                island.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nextRow,nextCol&#125;);<br>                            &#125; <br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>[] cell : island)&#123;<br>                    queue.add(cell);<br>                &#125;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">step</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">sz</span> <span class="hljs-operator">=</span> queue.size();<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; sz; k++)&#123;<br>                        <span class="hljs-type">int</span>[] cell = queue.poll();<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> cell[<span class="hljs-number">0</span>], y = cell[<span class="hljs-number">1</span>];<br>                        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; d &lt; <span class="hljs-number">4</span>; d++)&#123;<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">nx</span> <span class="hljs-operator">=</span> x + dirs[d][<span class="hljs-number">0</span>];<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">ny</span> <span class="hljs-operator">=</span> y + dirs[d][<span class="hljs-number">1</span>];<br>                            <span class="hljs-keyword">if</span>(nx &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n)&#123;<br>                                <span class="hljs-keyword">if</span>(grid[nx][ny] == <span class="hljs-number">0</span>)&#123;<br>                                    queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;nx, ny&#125;);<br>                                    grid[nx][ny] = -<span class="hljs-number">1</span>;<br>                                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(grid[nx][ny] == <span class="hljs-number">1</span>)&#123;<br>                                    <span class="hljs-keyword">return</span> step;<br>                                &#125;<br>                            &#125;<br>                        &#125;<br><br>                    &#125;<br>                    step++;<br>                &#125; <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>广度优先遍历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-915分割数组</title>
    <link href="/2022/10/24/leetcode-915%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84/"/>
    <url>/2022/10/24/leetcode-915%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partitionDisjoint</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxLeft</span> <span class="hljs-operator">=</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> maxLeft;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &lt; maxLeft)&#123;   <span class="hljs-comment">// 在默认情况下右侧值一直大于左侧值，当出现右侧值小于左侧值时更新左侧值为目前位置的最大值 </span><br>                maxLeft = max;<br>                ans = i;<br>            &#125;<br>            max = Math.max(max, nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans+<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>翻转卡片loading</title>
    <link href="/2022/10/23/%E7%BF%BB%E8%BD%AC%E5%8D%A1%E7%89%87loading/"/>
    <url>/2022/10/23/%E7%BF%BB%E8%BD%AC%E5%8D%A1%E7%89%87loading/</url>
    
    <content type="html"><![CDATA[<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.cardLoading</span>&#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">60px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">60px</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">87</span>, <span class="hljs-number">88</span>, <span class="hljs-number">88</span>);<br>  <span class="hljs-attribute">animation</span>: cardAnimation <span class="hljs-number">1.2s</span> infinite ease-in-out;<br>&#125;<br><span class="hljs-keyword">@keyframes</span> cardAnimation &#123;<br>    <span class="hljs-number">0%</span>&#123;<br>      <span class="hljs-attribute">transform</span>:  <span class="hljs-built_in">perspective</span>(<span class="hljs-number">120px</span>) <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">0deg</span>) <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">0deg</span>);<br>    &#125;<br>    <span class="hljs-number">50%</span>&#123;<br>      <span class="hljs-attribute">transform</span>:  <span class="hljs-built_in">perspective</span>(<span class="hljs-number">120px</span>) <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">180deg</span>) <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">0deg</span>);<br>    &#125;<br>    <span class="hljs-number">100%</span>&#123;<br>      <span class="hljs-attribute">transform</span>:  <span class="hljs-built_in">perspective</span>(<span class="hljs-number">120px</span>) <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">180deg</span>) <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">180deg</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-6027统计定界子数组的数目</title>
    <link href="/2022/10/16/leetcode-6027%E7%BB%9F%E8%AE%A1%E5%AE%9A%E7%95%8C%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/"/>
    <url>/2022/10/16/leetcode-6027%E7%BB%9F%E8%AE%A1%E5%AE%9A%E7%95%8C%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="题目-本题为第315场周赛第四题"><a href="#题目-本题为第315场周赛第四题" class="headerlink" title="题目 本题为第315场周赛第四题"></a>题目 本题为第315场周赛第四题</h1><p>给你一个整数数组 nums 和两个整数 minK 以及 maxK 。</p><p>nums 的定界子数组是满足下述条件的一个子数组：</p><p>子数组中的 最小值 等于 minK 。<br>子数组中的 最大值 等于 maxK 。<br>返回定界子数组的数目。</p><p>子数组是数组中的一个连续部分。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/count-subarrays-with-fixed-bounds">https://leetcode.cn/problems/count-subarrays-with-fixed-bounds</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="步骤模拟："><a href="#步骤模拟：" class="headerlink" title="步骤模拟："></a>步骤模拟：</h1><p>设置下表indexMax和indexMin以及不符合条件的下表k, 那么每次更新k的值, Min(indexMax, indexMin)至k之间的值为符合条件的数字。<br><img src="/2022/10/16/leetcode-6027%E7%BB%9F%E8%AE%A1%E5%AE%9A%E7%95%8C%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/image.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countSubarrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> minK, <span class="hljs-type">int</span> maxK)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">indexMin</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, indexMax = -<span class="hljs-number">1</span>, k = -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == minK)&#123;<br>                indexMin = i;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[i] == maxK)&#123;<br>                indexMax = i;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(nums[i] &lt; minK || nums[i] &gt; maxK)&#123;<br>                k = i;<br>            &#125;<br>            ans = ans + Math.max(Math.min(indexMax, indexMin) - k, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-769 最多能完成排序的块</title>
    <link href="/2022/10/13/leetcode-769-%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97/"/>
    <url>/2022/10/13/leetcode-769-%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目-给定一个长度为-n-的整数数组-arr-，它表示在-0-n-1-范围内的整数的排列。"><a href="#题目-给定一个长度为-n-的整数数组-arr-，它表示在-0-n-1-范围内的整数的排列。" class="headerlink" title="题目 给定一个长度为 n 的整数数组 arr ，它表示在 [0, n - 1] 范围内的整数的排列。"></a>题目 给定一个长度为 n 的整数数组 arr ，它表示在 [0, n - 1] 范围内的整数的排列。</h2><p>我们将 arr 分割成若干 块 (即分区)，并对每个块单独排序。将它们连接起来后，使得连接的结果和按升序排序后的原数组相同。</p><p>返回数组能分成的最多块数量。</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/max-chunks-to-make-sorted">https://leetcode.cn/problems/max-chunks-to-make-sorted</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="贪心以左边界为分界点不能处理非连续的分割点-只能通过部分用例"><a href="#贪心以左边界为分界点不能处理非连续的分割点-只能通过部分用例" class="headerlink" title="贪心以左边界为分界点不能处理非连续的分割点 只能通过部分用例"></a>贪心以左边界为分界点不能处理非连续的分割点 只能通过部分用例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxChunksToSorted</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, max = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[i] == index)&#123;<br>                ans++;<br>                index = max + <span class="hljs-number">1</span>;<br>                max =  index;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                max = Math.max(max, arr[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="贪心存储最远距离当-i-x3D-x3D-max时表示有效分割-事件复杂度O-n-空间复杂度O-1"><a href="#贪心存储最远距离当-i-x3D-x3D-max时表示有效分割-事件复杂度O-n-空间复杂度O-1" class="headerlink" title="贪心存储最远距离当 i&#x3D;&#x3D;max时表示有效分割 事件复杂度O(n)空间复杂度O(1)"></a>贪心存储最远距离当 i&#x3D;&#x3D;max时表示有效分割 事件复杂度O(n)空间复杂度O(1)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxChunksToSorted</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++)&#123;<br>            max = Math.max(max, arr[i]);<br>            <span class="hljs-keyword">if</span>(i == max)&#123;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-64 最小路径和</title>
    <link href="/2022/10/12/leetcode-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2022/10/12/leetcode-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h1><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><h1 id="步骤模拟："><a href="#步骤模拟：" class="headerlink" title="步骤模拟："></a>步骤模拟：</h1><p>假设当前的坐标点为第一行那么[0, j] 点的值 sum &#x3D; grid[0][j-1] + grid[0][j], 如果为第一列[0, i] sum &#x3D; grid[j][0] + grid[j - 1][0], [0,0]点为起始点 sum &#x3D; grid[0][0]。假设当前点为[i,j], 那么走到[i,j]点只有两种可能[i-1, j]或[i, j-1] 此时可推得转移公式 sum &#x3D; grid[i][j] + Math.max(grid[i - 1][j], grid[i][j-1])。<br><img src="/2022/10/12/leetcode-64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/image.jpg"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> grid.length, col = grid[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-type">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[row][col];<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; row; i++)&#123;<br>            dp[i][<span class="hljs-number">0</span>] = grid[i][<span class="hljs-number">0</span>] + dp[i-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; col; j++)&#123;<br>            dp[<span class="hljs-number">0</span>][j] = grid[<span class="hljs-number">0</span>][j] + dp[<span class="hljs-number">0</span>][j-<span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; row; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; col; j++)&#123;<br>                dp[i][j] = Math.min(dp[i-<span class="hljs-number">1</span>][j], dp[i][j-<span class="hljs-number">1</span>]) + grid[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[row-<span class="hljs-number">1</span>][col-<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-665非递减数列</title>
    <link href="/2022/10/10/leetcode-665%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/"/>
    <url>/2022/10/10/leetcode-665%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h1><p>计算所有位置前不符合 nums[i] &gt; nums[i-1]的个数只可以通过部分测试用例 例如:[3,4,2,3]是不符合条件的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkPossibility</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; nums[i-<span class="hljs-number">1</span>])&#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                dp[i] = dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[nums.length - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="思路-1"><a href="#思路-1" class="headerlink" title="思路:"></a>思路:</h1><p>对于步骤进行分类讨论如图所示：<br><img src="C:\Users\lvyan\Desktop\hexo\public\img\leetcode665.jpg" alt="图片"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkPossibility</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &lt; nums[i - <span class="hljs-number">1</span>])&#123;<br>                sum++;<br>                <span class="hljs-keyword">if</span>(sum &gt;= <span class="hljs-number">2</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i-<span class="hljs-number">2</span>] &lt; nums[i])&#123;<br>                    nums[i - <span class="hljs-number">1</span>] =  nums[i];<br>                &#125;<br>                <span class="hljs-keyword">if</span>(i - <span class="hljs-number">2</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i-<span class="hljs-number">2</span>] &gt; nums[i])&#123;<br>                    nums[i] = nums[i-<span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>贪心算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-974可被k整除的子数组</title>
    <link href="/2022/09/14/leetcode-974%E5%8F%AF%E8%A2%ABk%E6%95%B4%E9%99%A4%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2022/09/14/leetcode-974%E5%8F%AF%E8%A2%ABk%E6%95%B4%E9%99%A4%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h1><p>前缀和+同余定理+取余运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subarraysDivByK</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        map.put(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num: nums)&#123; <br>            sum = sum + num;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">modulus</span> <span class="hljs-operator">=</span> (sum % k + k) % k;<br>            <span class="hljs-keyword">if</span>(map.containsKey(modulus))&#123;<br>               <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> map.get(modulus);<br>               map.put(modulus, a + <span class="hljs-number">1</span>);<br>               ans = ans + a;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                map.put(modulus, <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前缀和</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-11盛水最多的容器</title>
    <link href="/2022/07/03/leetcode-11%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
    <url>/2022/07/03/leetcode-11%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h1><p>当从两端开始时长度最长,此时影响盛水量的将是较低的值，所以将高度较低的值舍弃。将左右指针对撞时完成遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span>  height.length, left = <span class="hljs-number">0</span>, right = height.length - <span class="hljs-number">1</span>, max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> Math.min(height[left], height[right]) * (right - left);<br>            max = Math.max(area, max);<br>            <span class="hljs-keyword">if</span>(height[left] &lt; height[right])&#123;<br>                left++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>双指针</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode-9回文数</title>
    <link href="/2022/06/26/leetcode-9%E5%9B%9E%E6%96%87%E6%95%B0/"/>
    <url>/2022/06/26/leetcode-9%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">reverse</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span> || (x % <span class="hljs-number">10</span>) == <span class="hljs-number">0</span> &amp;&amp; x != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(reverse &lt; x)&#123;<br>            reverse = x % <span class="hljs-number">10</span> + reverse * <span class="hljs-number">10</span>;<br>            x = x /<span class="hljs-number">10</span>;<br>        &#125;<br>   <br>        <span class="hljs-type">return</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span>= reverse || x == reverse/<span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础编码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Element.getBoundingClientRect()简介</title>
    <link href="/2022/06/25/Element-getBoundingClientRect-%E7%AE%80%E4%BB%8B/"/>
    <url>/2022/06/25/Element-getBoundingClientRect-%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>概述：在了解这个函数钩子前我们先了解两个有用的内置属性值:<br>(1) window.innerHtmlHeight&#x2F;width 这个属性指当前浏览器页面的高度或宽度(不包含滚动条距离)。<br>(2) Element.clientHeight&#x2F;width 表示当前元素的宽度和高度不包含元素的边框<br>(3) Element.offsetHeight&#x2F;width 包含元素的边框<br>getBoundingClientRect() 会返回如下值：<br>(1) width&#x2F;height: 包含padding和border(所以此时值和offsetHeight&#x2F;width相等)<br>(2) top&#x2F;left: 元素左上顶点对于视口的距离不包含滚动距离<br>(3) bottom&#x2F;right: 右下的距离不包含滚动条的距离<br>(4) X&#x2F;Y的值大小和left&#x2F;top相等</p>]]></content>
    
    
    <categories>
      
      <category>有用的函数钩子</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>computed与闭包</title>
    <link href="/2022/06/18/computed%E4%B8%8E%E9%97%AD%E5%8C%85/"/>
    <url>/2022/06/18/computed%E4%B8%8E%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h1><p> 计算属性具有缓存的特点, 特别是当我们一个值的变换因对各值而引起时此时计算属性相对有用。但是，计算属性不能接收参数此时该如何解决哪。</p><h2 id="闭包："><a href="#闭包：" class="headerlink" title="闭包："></a>闭包：</h2><p> 因为计算属性本身不接受参数， 为了可以传参且可以对当前的计算属性可以继续调用,自然而然想到使用闭包返回一个函数的方法。<br> 具体代码举例如下:<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javaScript"> <span class="hljs-attr">computedOne</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">x,y</span>) &#123;<br>          <span class="hljs-keyword">return</span> x+y<br>        &#125;<br>&#125;,<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>问题归档</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
